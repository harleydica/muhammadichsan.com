---
title: 'Understanding the Segment Register with its implementation in x86 architecture'
summary: 'Seeing what happens inside the registers when our assembly code is executed is a great way to learn about the registers itself.'
featured: true
author_name: 'Muhammad Ichsanul Fadhil'
author_image: 'https://ik.imagekit.io/mlnzyx/tr:w-32,h-32/attachment/profile.webp'
published: '12/7/2022'
topics: ['Computer Science']
keywords:
  ['register','computer science']
related: []
---

Register is a memory unit that has a very small capacity, has the fastest speed, and is located very close to the processing unit of the processor. In the x86 architecture especially IA-32 (32bit) there are about 16 registers that you can find, each register has its own function and they have a memory capacity of 32bit.

To study these registers, we can debug the assembly code that we run. With a tool called GDB later we will be able to see the contents of the register in real time with every assembly instruction that we give.

Okay no need to take too long, let's do that now ðŸš“

## Preparation ðŸ³

For basic knowledge the figure below explains the level of each register. For general purpose registers, we can break them down into smaller bytes, for example EAX (32bit) has AX (16bit) and AH & AL (8bit) parts.

![Register Structure](https://ik.imagekit.io/uvma3bkbp/Screenshot_from_2022-07-14_18-06-27_WKZ-c1TfZj.png?ik-sdk-version=javascript-1.4.3&updatedAt=1657796975551 'Commitizen Prompt on terminal')

We will use several tools for viewing and debugging the contents of the register, those tools are.

- NASM Assembler (Linux)
- GDB Debugger
- Any linux distro

And for practice, make sure you've studied assembly language, at least you've used the MOV command, that's enough ðŸ‘Œ

## Lets see the contents of each register ðŸ”Ž

x86 architecture has at least 16 registers and they are divided into 4 parts according to their function, they are General Purpose Register, Segment, Pointer, and Indicator.

Let's start with the General Purpose Register first.

### General Purpose Register

General purpose register consists of 4 registers, there are EAX, EBX, ECX, and EDX. Each register has a memory capacity of 32 bits or 8 bytes.

You can use the four registers for anything, whether it's to store variables, instructions, or data.

There are no special rules regarding the contents of these registers, but usually the programmers set the four registers to be used in some way, for example.

- Accumulator register (EAX) = for store arithmatic operation and result data
- Base register (BX) = pointer to data in memory (located in segment register DS, when you use segmented addressing)
- Counter register (CX) = used for shift/rotate instructions and loops
- Data register (DX) = arithmetic operations and I/O operations.

To see the contents of the general purpose register here i have prepared a simple x86 program, please copy the program below and compile the code using the command `nasm -f elf -g -F dwarf a.asm` then linking with `ld -m elf_i386 -o a a.o`.

```wasm
section .text

global _start

_start:
    mov eax, 0x474A3B ; fill 24bit data to register eax
    mov bx, 1001001111110000b ; fill 16 bit data binary to ebx
```
When we run the program, there are 2 things that will happen in the processor, first is filling the binary value of 474A3B hexadecimal to the EAX register and filling 1001001111110000 to the AX register. Using `gdb a` command we can debug that program and see the contents of the content register step by step.

![Content of Register](https://ik.imagekit.io/uvma3bkbp/Screenshot_from_2022-07-14_19-51-40_PKbsIpSIO.png?ik-sdk-version=javascript-1.4.3&updatedAt=1657854507307 'Content of Register')

> After you run `gdb a` command, then you can then set a breakpoint using the `br 1` then run `start` and run the instructions line by line with `stepi`. Look at the contents of the register carefully after you run `stepi`. 

### Segment Register

Segment Register is a register used for segmentation, this register is usually used and combined with other registers to form a long memory address which is later used to read and write to memory.








